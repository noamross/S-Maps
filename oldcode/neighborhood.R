# Multiple functions for finding nearest neighbors and simplexes
mat <- function(x, h=FALSE) {
    if(is.vector(x)) {
      if(h) t(as.matrix(x)) else (as.matrix(x))
    } else x
}


	
#' Identify neighboring points
#'
#' This functon identifies points from a cloud  in \emph{n}-dimensional space 
#' near the target points, for the purpose of determining the neighborhood
#' from which to project future behavior
#'
#' @param targets a matrix whose rows are target points and whose columns are 
#' their coordinates in n-dimensional space, such as generated by 
#' \code{\link{embed.series}}.
#' @param cloud a matrix whose rows are the points in the cloud and whose 
#' columns are their coordinates in n-dimensional space, such as generated by
#' \code{\link{embed.series}}.
#' @param method the method for finding neighbors.  Default is "simplex", which
#' identifies nearest n+1 nearest neighbors tices of the simplex enclosing each 
#' target point.  
#' \code{"nn"} identifies nearest euclidean neighbors.
#' \code{"diameter"} identifies the smallest diameter simplex
#' \code{"volume"} identifies the smallest volume simplex
#' @param n if "nn" method is selected, the number of nearest neighbors to select
#' default is n+1, where n is dimensions of the target and cloud datasets
#' @param boundary if any of the simplex methods are used, what to do with points
#' that have no enclosing simplex. The default, \code{"nn"}, finds the nearest 
#' euclidean neighbors. "null" returns null values for these.
neighborhood <- function(targets, cloud, method = "simplex", boundary = "nn", 
												 n = ncol(targets) + 1, cvdistmat=NULL, cvn=NULL) {					

	if (ncol(targets) != ncol(cloud)) stop("targets and cloud must be of same 
																					dimension (column number)")
	if (!is.matrix(targets) | !is.matrix(cloud)) stop("targets and cloud must be 
																										matrics")
	
	if (method == "nn") neighbors <- nearest.neighbors(targets, cloud, n)
	if (method == "simplex") neighbors <- nearest.simplex(targets, cloud, boundary, cvdistmat=NULL, cvn=NULL)
  
  for(i in 1:nrow(targets))
    if(sum(targets[i, ] %in% cloud[neighbors$indices[i, ], ]) > 0) {
      neighbors$flag[i] <-2
      }
    return(list(indices = neighbors$indices, distances = neighbors$distances, 
                totdistance = neighbors$totdistance, flag = neighbors$flag))
}
#' Identify the nearest neighbors of targets
#'
#' @param targets a matrix whose rows are target points and whose columns are 
#' their coordinates in n-dimensional space, such as generated by 
#' \code{\link{embed.series}}.
#' @param cloud a matrix whose rows are the points in the cloud and whose 
#' columns are their coordinates in n-dimensional space, such as generated by
#' \code{\link{embed.series}}.
#' @param num the number of nearest neigbors to select default is the
#' dimensionality of the vectors plus one (a simplex)
#' @return indices a matrix of equal length to \code{targets}, with \code{num}
#' columns, listing the indices in \code{cloud} of the nearest neighbors
#' @return distances a matrix of the same length as indices, with the distance
#' to each neighbor
#' @return totdistance the sum of distances from each target to all its 
#' neighbors
# @import yaImpute
nearest.neighbors <- function(targets, cloud, num = ncol(targets) + 1) {
	if (ncol(targets) != ncol(cloud)) {
    stop("targets and cloud must be of same dimension (column number)")
	  }
	if (!is.matrix(targets) | !is.matrix(cloud)) {
    stop("targets and cloud must be matrics")
	  }	
	neighbors <- ann(target = targets, ref = cloud, k = num, verbose = FALSE)
	neighbor.indices <- mat(neighbors$knnIndexDist[, 1:num])
	neighbor.distances <- mat(neighbors$knnIndexDist[, (num + 1):(2 * num)])
  neighbor.totdistance <- rowSums(neighbor.distances)
  neighbor.flag <- NULL
#  colnames(neighbor.flag) <- c("outofsample", "sharesvalue", "sharespint")
  return(list(indices = neighbor.indices, distances = neighbor.distances, 
              totdistance = neighbor.totdistance, flags <- neighbor.flag))
  }

#' Identify the closest simplex of points around the target
#' 
#' This function identifies the n+1 points in the cloud of points that contain
#' the target point(s) and have the shortest distances to the target.  It does
#' so by finding the solution of a set of linear equations.  
#  The functions \code{\link{lowestvol.simplex}} and 
#' \code{\link\{lowestdaim.simplex}} call this as part of their search
#'
#' @param targets a matrix whose rows are target points and whose columns are 
#' their coordinates in n-dimensional space, such as generated by 
#' \code{\link{embed.series}}.
#' @param cloud a matrix whose rows are the points in the cloud and whose 
#' columns are their coordinates in n-dimensional space, such as generated by
#' \code{\link{embed.series}}.
#' @param boundary  what to do with points that have no enclosing simplex. The 
#' default, \code{"nn"}, finds the nearest euclidean neighbors. "NA" returns 
#' NA values for these.
#' @import lpSolve

nearest.simplex <- function(targets, cloud, boundary = "nn", cvdistmat=NULL, cvn=NULL) {
  times <- targets[,"Time"]
  targs <- targets[,2:(1+attr(targets,"dimensions"))]; dim(targs) <- c(length(targs)/attr(targets,"dimensions"), attr(targets,"dimensions")); targets <- targs
  clo <- cloud[,2:(1+attr(cloud,"dimensions"))]; dim(clo) <- c(length(clo)/attr(cloud,"dimensions"), attr(cloud,"dimensions")); cloud <- clo
  if(is.null(cvdistmat)) {
    distmat <- as.matrix(dist(rbind(targets,cloud),diag=TRUE,upper=TRUE))
  } else {
    distmat <- matrix(nrow=nrow(cvdistmat), ncol=ncol(cvdistmat))
    distmat[1, ] <- cvdistmat[cvn, ]
    distmat[, 1] <- cvdistmat[, cvn]
    distmat[2:nrow(distmat),2:ncol(distmat)] <- cvdistmat[-cvn, -cvn]
  }
  indices <- matrix(NA, nrow = nrow(targets), ncol = ncol(targets)+ 1)
  distances <- indices
  flag <- rep(0, length.out <- nrow(targets))
  for (i in 1:nrow(targets)) {
    objective <- distmat[i, (nrow(targets) + 1):(nrow(targets) + nrow(cloud))]
    constraint <- rbind(t(cloud), rep(1, length.out = nrow(cloud)))
    constraint.sign <- rep("=", length.out = ncol(cloud) + 1)
    constraint.rhs <- c(targets[i, ], 1)
    out.lp <- lp("min", objective, constraint, constraint.sign, constraint.rhs)
    if (sum(out.lp$solution != 0) != (nrow(targets) + 1)) {
      indices[i, ] <- rep(NA, length.out = ncol(indices))
      distances[i, ] <- rep(NA, length.out = ncol(distances))
    }
    else {
      indices[i, ] <- which(out.lp$solution != 0)
      distances[i, ] <- distmat[i, indices[i, ] + nrow(targets)]
    }
  }
  flag[which(is.na(indices[, 1]))] <- 1
  if (boundary == "nn" && sum(flag) > 0) {
    if(ncol(targets) == 1) flagged <- t(mat(targets[which(flag==1), ]))
      else flagged <- mat(targets[which(flag==1), ])
    boundary = nearest.neighbors(flagged, cloud)
    indices[which(flag==1), ] <- boundary$indices
    distances[which(flag==1), ] <- boundary$distances
    }
  totdistance <- rowSums(distances)
  return(list(indices = indices, distances = distances, 
              totdistance = totdistance, flag=flag))
}