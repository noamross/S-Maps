
	
#' Identify neighboring points
#'
#' This functon identifies points from a cloud  in \emph{n}-dimensional space 
#' near the target points, for the purpose of determining the neighborhood
#' from which to project future behavior
#'
#' @param targets a matrix whose rows are target points and whose columns are their coordinates in n-dimensional space, such as generated by \code{\link{embed.series}}.
#' @param cloud a matrix whose rows are the points in the cloud and whose columns are their coordinates in n-dimensional space, such as generated by \code{\link{embed.series}}.
#' @param method the method for finding neighbors.  Default is "simplex", which identifies the points which are the n+1 vertices of the smallest simplex enclosing each target point.  \code{"nn"} identifies nearest euclidean neighbors.
#' @param boundary if \code{method="simplex"}, how to deal with points that have no enclosing simplex.  The default, \code{"nn"}, finds the nearest euclidean neighbors. "null" returns null values for these.
#' @param n if \code{method = nn}, determines the number of nearest neighbors to select
neighborhood <- function(targets, cloud, method = "simplex", boundary = "nn", n = NULL) {									#predict forward, using simplex data for those that have it and nearest neighbor for those that don't
	dimension <- dim(targets)[2]
	neighbors <- containing.simplexes(targets, cloud)
	edgecases <- which(rowSums(neighbors) == 0)
	edgetargets <- if(is.matrix(targets[edgecases,])) targets[edgecases,] else as.matrix(targets[edgecases,])
	edgeneighbors <- ann(cloud, edgetargets, k=dimension+1, verbose=FALSE )
	neighbors[edgecases,] <- edgeneighbors$knnIndexDist
	nhood <- list(ind=neighbors[,1:(dimension+1)], dist=neighbors[,(dimension+2):(2*dimension+2)])
}

containing.simplexes <- function(targets, cloud) {															
		ncloud <- dim(cloud)[1]
		ntargets <- dim(targets)[1]
		distances <- as.matrix(dist(rbind(targets, cloud),diag=TRUE, upper=TRUE ))        								#a vector of distances between the target and the cloud points, TODO: Make this more efficient I might just call it once for all data
		vertices <- t(sapply(1:ntargets, function(z) {
											   containing.simplex(targets[z,], cloud, 
											 	 distances[z, (ntargets+1):(ntargets+ncloud)], ncloud)
													}))
		vertex.distances <- t(sapply(1:ntargets, function(z) distances[z,vertices[1,]+ntargets]))
		vertex.distances[which(rowSums(vertices)==0),] <- 0
		cbind(vertices, vertex.distances)
	}
	
containing.simplex <- function(target, cloud, distances, m) {
		objective <- distances																												# The objective function is of the form lambda1*distance1 + lambda2*distance2 + ...
		constraint <- rbind(t(cloud), rep(1,length.out=m))														#coefficients for the contraints note that the solver assumes that all the variables are >=0
		constraint.sign <- c(rep("=", length.out = dim(cloud)[2]), "<=")													#equalities/inequalities for the contraints
		constraint.rhs <- c(target, 1)																								#
		out.lp <- lp("min", objective, constraint, constraint.sign, constraint.rhs)
		vertices <- which(out.lp$solution!=0)
		if(length(vertices) != ncol(target)+1) vertices <- rep(0,(dim(cloud)[2]+1))
		return(vertices)
	}
	
simplex.content <- function(vertices) { #TODO: Test this!  It might need an absolute to get rid of negative content results. Add signed=FALSE?
#See http://www.mathpages.com/home/kmath664/kmath664.htm
#Content is distance for 1-D, area for 2-D, volume for 3-D, etc.  In units of length^n
#' @param vertices an (n + 1) X n matrix, whose rows are the coordinates in n-D space of the vertices of the simplex
	volume <-  det(cbind(rep(1, nrow(vertices)), vertices)) / factorial(ncol(vertices))
}
	
simplex.diameter <- function(vertices) {
	diameter <- max(dist(vertices))
}

search.simplexes <- function(target, cloud) { #find the simplex that meets search criteria for smallest diameter/volume	
	dimension = ncol(cloud)
	i = 1
	searched = matrix(NaN, nrow=1000, ncol = (2* dimension) + 4)
	keepsearch <- TRUE
	while (keepsearch == TRUE) {
		nearest <- ann(ref=cloud, target=target, k=dimension + i, verbose=FALSE)
		nearest.indices <- nearest$knnIndexDist[1, 1:(dimension + i)]
		nearest.dist <- nearest$knnIndexDist[1,(dimension + i + 1):(2* (dimension + i))]
		combinations <- combn(x = 1:(dimension + i), m = dimension + 1, )
		combinations <- as.matrix(combinations[, (choose(dimension + i - 1, dimension + 1) + 1):ncol(combinations) ])
		for (j in 1:ncol(combinations)) {
			distances = nearest.dist[combinations[,j]]
			indices = nearest.indices[combinations[,j]]
			insim <- sum(containing.simplex(target, cloud[indices,], distances, dimension+1)) > 0
			distance = sum(distances)
			searched[i + j - 1,] = c(indices, insim, distances, distance)
			}
		if(max(searched[,ncol(searched)], na.rm=TRUE) > 2*min(searched[,ncol(searched)], na.rm=TRUE)) keepsearch <- FALSE
		i = i + 1
		}
		return(searched)
	}

	
cloud = matrix(rnorm(50),nrow=25)
target = matrix(rnorm(2),nrow=1)